// Package uspsinternal provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package uspsinternal

import (
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	OAuthScopes = "OAuth.Scopes"
)

// Defines values for AddressAdditionalInfoDPVCMRA.
const (
	AddressAdditionalInfoDPVCMRAN AddressAdditionalInfoDPVCMRA = "N"
	AddressAdditionalInfoDPVCMRAY AddressAdditionalInfoDPVCMRA = "Y"
)

// Defines values for AddressAdditionalInfoDPVConfirmation.
const (
	AddressAdditionalInfoDPVConfirmationD AddressAdditionalInfoDPVConfirmation = "D"
	AddressAdditionalInfoDPVConfirmationN AddressAdditionalInfoDPVConfirmation = "N"
	AddressAdditionalInfoDPVConfirmationS AddressAdditionalInfoDPVConfirmation = "S"
	AddressAdditionalInfoDPVConfirmationY AddressAdditionalInfoDPVConfirmation = "Y"
)

// Defines values for AddressAdditionalInfoBusiness.
const (
	AddressAdditionalInfoBusinessN AddressAdditionalInfoBusiness = "N"
	AddressAdditionalInfoBusinessY AddressAdditionalInfoBusiness = "Y"
)

// Defines values for AddressAdditionalInfoCentralDeliveryPoint.
const (
	AddressAdditionalInfoCentralDeliveryPointN AddressAdditionalInfoCentralDeliveryPoint = "N"
	AddressAdditionalInfoCentralDeliveryPointY AddressAdditionalInfoCentralDeliveryPoint = "Y"
)

// Defines values for AddressAdditionalInfoVacant.
const (
	N AddressAdditionalInfoVacant = "N"
	Y AddressAdditionalInfoVacant = "Y"
)

// Address Address fields standard to all locations.
type Address struct {
	// CityAbbreviation This is the abbreviation of the city name for the address.
	CityAbbreviation *string `json:"cityAbbreviation,omitempty"`

	// SecondaryAddress The secondary unit designator, such as apartment(APT) or suite(STE) number, defining the exact location of the address within a building.  For more information please see [Postal Explorer](https://pe.usps.com/text/pub28/28c2_003.htm).
	SecondaryAddress *string `json:"secondaryAddress,omitempty"`

	// StreetAddress The number of a building along with the name of the road or street on which it is located.
	StreetAddress *string `json:"streetAddress,omitempty"`

	// StreetAddressAbbreviation This is the abbreviation of the primary street address line for the address.
	StreetAddressAbbreviation *string                `json:"streetAddressAbbreviation,omitempty"`
	AdditionalProperties      map[string]interface{} `json:"-"`
}

// AddressAdditionalInfo Extra information about the request.
type AddressAdditionalInfo struct {
	// DPVCMRA Indicates if the location is a [Commercial Mail Receiving Agency (CMRA)](https://faq.usps.com/s/article/Commercial-Mail-Receiving-Agency-CMRA).
	//  * `Y` - Address was found in the CMRA table.
	//  * `N` - Address was not found in the CMRA table.
	DPVCMRA *AddressAdditionalInfoDPVCMRA `json:"DPVCMRA,omitempty"`

	// DPVConfirmation The DPV Confirmation indicator identifies whether the address provided maps to a known USPS address record, whether the USPS delivers to the address or not. If the USPS does not deliver to the address, the USPS may deliver to a PO Box instead. `carrierRoute` values of `R777` and `R779`, for example, may require the shipper to ask the recipient where they receive their USPS mail, which may be different than their physical address.
	//
	// * `Y` - Address was DPV confirmed for both primary and (if present) secondary numbers.  A value of `Y` does not necessarily imply that USPS delivers to that address.
	// * `D` - Address was DPV confirmed for the primary number only, and the secondary number information was missing.
	// * `S` - Address was DPV confirmed for the primary number only, and the secondary number information was present but not confirmed.
	// * `N` - Both primary and (if present) secondary number information failed to DPV confirm.
	DPVConfirmation *AddressAdditionalInfoDPVConfirmation `json:"DPVConfirmation,omitempty"`

	// Business Indicates whether this is a business address.
	// * `Y` - The address is a business address.
	// * `N` - The address is not a business address.
	Business *AddressAdditionalInfoBusiness `json:"business,omitempty"`

	// CarrierRoute This is the carrier route code (values unspecified).
	CarrierRoute *string `json:"carrierRoute,omitempty"`

	// CentralDeliveryPoint Central Delivery is for all business office buildings and/or industrial/professional parks. This may include call windows, horizontal locked mail receptacles, and cluster box units.
	// * `Y` - The address is a central delivery point.
	// * `N` - The address is not a central delivery point.
	CentralDeliveryPoint *AddressAdditionalInfoCentralDeliveryPoint `json:"centralDeliveryPoint,omitempty"`

	// DeliveryPoint A specific set of digits between 00 and 99 is assigned to every address that is combined with the ZIP + 4&#174; Code to provide a unique identifier for every delivery address.
	//
	// A street address does not necessarily represent a single delivery point because a street address such as one for an apartment building may have several delivery points.
	DeliveryPoint *string `json:"deliveryPoint,omitempty"`

	// Vacant Indicates whether the location designated by the address is occupied.
	// * `Y` - The address is not occupied.
	// * `N` - The address is occupied.
	Vacant *AddressAdditionalInfoVacant `json:"vacant,omitempty"`
}

// AddressAdditionalInfoDPVCMRA Indicates if the location is a [Commercial Mail Receiving Agency (CMRA)](https://faq.usps.com/s/article/Commercial-Mail-Receiving-Agency-CMRA).
//   - `Y` - Address was found in the CMRA table.
//   - `N` - Address was not found in the CMRA table.
type AddressAdditionalInfoDPVCMRA string

// AddressAdditionalInfoDPVConfirmation The DPV Confirmation indicator identifies whether the address provided maps to a known USPS address record, whether the USPS delivers to the address or not. If the USPS does not deliver to the address, the USPS may deliver to a PO Box instead. `carrierRoute` values of `R777` and `R779`, for example, may require the shipper to ask the recipient where they receive their USPS mail, which may be different than their physical address.
//
// * `Y` - Address was DPV confirmed for both primary and (if present) secondary numbers.  A value of `Y` does not necessarily imply that USPS delivers to that address.
// * `D` - Address was DPV confirmed for the primary number only, and the secondary number information was missing.
// * `S` - Address was DPV confirmed for the primary number only, and the secondary number information was present but not confirmed.
// * `N` - Both primary and (if present) secondary number information failed to DPV confirm.
type AddressAdditionalInfoDPVConfirmation string

// AddressAdditionalInfoBusiness Indicates whether this is a business address.
// * `Y` - The address is a business address.
// * `N` - The address is not a business address.
type AddressAdditionalInfoBusiness string

// AddressAdditionalInfoCentralDeliveryPoint Central Delivery is for all business office buildings and/or industrial/professional parks. This may include call windows, horizontal locked mail receptacles, and cluster box units.
// * `Y` - The address is a central delivery point.
// * `N` - The address is not a central delivery point.
type AddressAdditionalInfoCentralDeliveryPoint string

// AddressAdditionalInfoVacant Indicates whether the location designated by the address is occupied.
// * `Y` - The address is not occupied.
// * `N` - The address is occupied.
type AddressAdditionalInfoVacant string

// AddressCorrections Codes that indicate how to improve the address input to get a better match.
//
// Code `32` will indicate "Default address: The address you entered was found but more information is needed (such as an apartment, suite, or box number." The recommended change would be to add additional information, such as an apartment, suite, or box number, to match to a specific address.
//
// Code `22` will indicate "Multiple addresses were found for the information you entered, and no default exists." The address could not be resolved as entered and more information would be needed to identify the address.
type AddressCorrections = []struct {
	// Code The code corresponding to the address correction.
	Code *string `json:"code,omitempty"`

	// Text This is the description of the address correction.
	Text *string `json:"text,omitempty"`
}

// AddressMatches Codes that indicate if an address is an exact match.
//
// Code `31` will be returned "Single Response - exact match" indicating that the address was correctly matched to a ZIP+4 record.
type AddressMatches = []struct {
	Code *string `json:"code,omitempty"`
	Text *string `json:"text,omitempty"`
}

// AddressResponse Standardizes street addresses including city and street abbreviations, and provides missing information such as ZIP Code&#8482; and ZIP + 4&#174;.
type AddressResponse struct {
	// AdditionalInfo Extra information about the request.
	AdditionalInfo *AddressAdditionalInfo `json:"additionalInfo,omitempty"`

	// Address Address fields for US locations
	Address *DomesticAddress `json:"address,omitempty"`

	// Corrections Codes that indicate how to improve the address input to get a better match.
	//
	// Code `32` will indicate "Default address: The address you entered was found but more information is needed (such as an apartment, suite, or box number." The recommended change would be to add additional information, such as an apartment, suite, or box number, to match to a specific address.
	//
	// Code `22` will indicate "Multiple addresses were found for the information you entered, and no default exists." The address could not be resolved as entered and more information would be needed to identify the address.
	Corrections *AddressCorrections `json:"corrections,omitempty"`

	// Firm This is the firm/business name at the address.
	Firm *string `json:"firm,omitempty"`

	// Matches Codes that indicate if an address is an exact match.
	//
	// Code `31` will be returned "Single Response - exact match" indicating that the address was correctly matched to a ZIP+4 record.
	Matches  *AddressMatches `json:"matches,omitempty"`
	Warnings *[]string       `json:"warnings,omitempty"`
}

// CityAndState defines model for CityAndState.
type CityAndState struct {
	// ZIPCode This is the ZIP Code of the address.
	ZIPCode *string `json:"ZIPCode,omitempty"`

	// City This is the city name of the address.
	City *string `json:"city,omitempty"`

	// State This is two-character state code of the address.
	State *string `json:"state,omitempty"`
}

// CityStateResponse defines model for CityStateResponse.
type CityStateResponse = CityAndState

// DomesticAddress defines model for DomesticAddress.
type DomesticAddress struct {
	// ZIPCode This is the 5-digit ZIP code.
	ZIPCode *string `json:"ZIPCode,omitempty"`

	// ZIPPlus4 This is the 4-digit component of the ZIP+4 code. Using the correct ZIP+4 reduces the number of times your mail is handled and can decrease the chance of a misdelivery or error.
	ZIPPlus4 *string `json:"ZIPPlus4"`

	// City This is the city name of the address.
	City *string `json:"city,omitempty"`

	// CityAbbreviation This is the abbreviation of the city name for the address.
	CityAbbreviation *string `json:"cityAbbreviation,omitempty"`

	// SecondaryAddress The secondary unit designator, such as apartment(APT) or suite(STE) number, defining the exact location of the address within a building.  For more information please see [Postal Explorer](https://pe.usps.com/text/pub28/28c2_003.htm).
	SecondaryAddress *string `json:"secondaryAddress,omitempty"`

	// State The two-character state code.
	State *State `json:"state,omitempty"`

	// StreetAddress The number of a building along with the name of the road or street on which it is located.
	StreetAddress *string `json:"streetAddress,omitempty"`

	// StreetAddressAbbreviation This is the abbreviation of the primary street address line for the address.
	StreetAddressAbbreviation *string `json:"streetAddressAbbreviation,omitempty"`

	// Urbanization An area, sector, or residential development within a geographic area (typically used for addresses in Puerto Rico).
	Urbanization         *string                `json:"urbanization,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ErrorMessage Standard error message response.
type ErrorMessage struct {
	// ApiVersion The version of the API that was used and that raised the error.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Error The high-level error that has occurred as indicated by the status code.
	Error                *ErrorMessage_Error    `json:"error,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ErrorMessage_Error_Errors_Source The element that is suspected of originating the error.  Helps to pinpoint the problem.
type ErrorMessage_Error_Errors_Source struct {
	// Example An example of a valid value for the input parameter.
	Example *string `json:"example,omitempty"`

	// Parameter The input in the request which caused an error.
	Parameter            *string                `json:"parameter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ErrorMessage_Error_Errors_Item defines model for ErrorMessage.Error.Errors.Item.
type ErrorMessage_Error_Errors_Item struct {
	// Code An internal subordinate code used for error diagnosis.
	Code *string `json:"code,omitempty"`

	// Detail A human-readable description of the error that occurred.
	Detail *string `json:"detail,omitempty"`

	// Source The element that is suspected of originating the error.  Helps to pinpoint the problem.
	Source *ErrorMessage_Error_Errors_Source `json:"source,omitempty"`

	// Status The status code response returned to the client.
	Status *string `json:"status,omitempty"`

	// Title A human-readable title that identifies the error.
	Title                *string                `json:"title,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ErrorMessage_Error The high-level error that has occurred as indicated by the status code.
type ErrorMessage_Error struct {
	// Code The error status code that has been returned in response to the request.
	Code   *string                           `json:"code,omitempty"`
	Errors *[]ErrorMessage_Error_Errors_Item `json:"errors,omitempty"`

	// Message A human-readable message describing the error.
	Message              *string                `json:"message,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// State The two-character state code.
type State = string

// ZIPCodeResponse The address to validate the ZIP Code&#8482; for.
type ZIPCodeResponse struct {
	// Address Address fields for US locations
	Address *DomesticAddress `json:"address,omitempty"`

	// Firm This is the firm/business name at the address.
	Firm *string `json:"firm,omitempty"`
}

// GetAddressParams defines parameters for GetAddress.
type GetAddressParams struct {
	// Firm Firm/business corresponding to the address.
	Firm *string `form:"firm,omitempty" json:"firm,omitempty"`

	// StreetAddress The number of a building along with the name of the road or street on which it is located.
	StreetAddress string `form:"streetAddress" json:"streetAddress"`

	// SecondaryAddress The secondary unit designator, such as apartment(APT) or suite(STE) number, defining the exact location of the address within a building.  For more information please see [Postal Explorer](https://pe.usps.com/text/pub28/28c2_003.htm).
	SecondaryAddress *string `form:"secondaryAddress,omitempty" json:"secondaryAddress,omitempty"`

	// City This is the city name of the address.
	City *string `form:"city,omitempty" json:"city,omitempty"`

	// State The two-character state code of the address.
	State string `form:"state" json:"state"`

	// Urbanization This is the urbanization code relevant only for Puerto Rico addresses.
	Urbanization *string `form:"urbanization,omitempty" json:"urbanization,omitempty"`

	// ZIPCode This is the 5-digit ZIP code.
	ZIPCode *string `form:"ZIPCode,omitempty" json:"ZIPCode,omitempty"`

	// ZIPPlus4 This is the 4-digit component of the ZIP+4 code. Using the correct ZIP+4 reduces the number of times your mail is handled and can decrease the chance of a misdelivery or error.
	ZIPPlus4 *string `form:"ZIPPlus4,omitempty" json:"ZIPPlus4,omitempty"`
}

// GetCityStateParams defines parameters for GetCityState.
type GetCityStateParams struct {
	// ZIPCode This is the 5-digit ZIP code.
	ZIPCode string `form:"ZIPCode" json:"ZIPCode"`
}

// GetZIPCodeParams defines parameters for GetZIPCode.
type GetZIPCodeParams struct {
	// Firm Firm/business corresponding to the address.
	Firm *string `form:"firm,omitempty" json:"firm,omitempty"`

	// StreetAddress The number of a building along with the name of the road or street on which it is located.
	StreetAddress string `form:"streetAddress" json:"streetAddress"`

	// SecondaryAddress The secondary unit designator, such as apartment(APT) or suite(STE) number, defining the exact location of the address within a building.  For more information please see [Postal Explorer](https://pe.usps.com/text/pub28/28c2_003.htm).
	SecondaryAddress *string `form:"secondaryAddress,omitempty" json:"secondaryAddress,omitempty"`

	// City This is the city name of the address.
	City string `form:"city" json:"city"`

	// State This is the two-character state code of the address.
	State string `form:"state" json:"state"`

	// ZIPCode This is the 5-digit ZIP code.
	ZIPCode *string `form:"ZIPCode,omitempty" json:"ZIPCode,omitempty"`

	// ZIPPlus4 This is the 4-digit component of the ZIP+4 code. Using the correct ZIP+4 reduces the number of times your mail is handled and can decrease the chance of a misdelivery or error.
	ZIPPlus4 *string `form:"ZIPPlus4,omitempty" json:"ZIPPlus4,omitempty"`
}

// Getter for additional properties for Address. Returns the specified
// element and whether it was found
func (a Address) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Address
func (a *Address) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Address to handle AdditionalProperties
func (a *Address) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cityAbbreviation"]; found {
		err = json.Unmarshal(raw, &a.CityAbbreviation)
		if err != nil {
			return fmt.Errorf("error reading 'cityAbbreviation': %w", err)
		}
		delete(object, "cityAbbreviation")
	}

	if raw, found := object["secondaryAddress"]; found {
		err = json.Unmarshal(raw, &a.SecondaryAddress)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryAddress': %w", err)
		}
		delete(object, "secondaryAddress")
	}

	if raw, found := object["streetAddress"]; found {
		err = json.Unmarshal(raw, &a.StreetAddress)
		if err != nil {
			return fmt.Errorf("error reading 'streetAddress': %w", err)
		}
		delete(object, "streetAddress")
	}

	if raw, found := object["streetAddressAbbreviation"]; found {
		err = json.Unmarshal(raw, &a.StreetAddressAbbreviation)
		if err != nil {
			return fmt.Errorf("error reading 'streetAddressAbbreviation': %w", err)
		}
		delete(object, "streetAddressAbbreviation")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Address to handle AdditionalProperties
func (a Address) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CityAbbreviation != nil {
		object["cityAbbreviation"], err = json.Marshal(a.CityAbbreviation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cityAbbreviation': %w", err)
		}
	}

	if a.SecondaryAddress != nil {
		object["secondaryAddress"], err = json.Marshal(a.SecondaryAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryAddress': %w", err)
		}
	}

	if a.StreetAddress != nil {
		object["streetAddress"], err = json.Marshal(a.StreetAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'streetAddress': %w", err)
		}
	}

	if a.StreetAddressAbbreviation != nil {
		object["streetAddressAbbreviation"], err = json.Marshal(a.StreetAddressAbbreviation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'streetAddressAbbreviation': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DomesticAddress. Returns the specified
// element and whether it was found
func (a DomesticAddress) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DomesticAddress
func (a *DomesticAddress) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DomesticAddress to handle AdditionalProperties
func (a *DomesticAddress) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ZIPCode"]; found {
		err = json.Unmarshal(raw, &a.ZIPCode)
		if err != nil {
			return fmt.Errorf("error reading 'ZIPCode': %w", err)
		}
		delete(object, "ZIPCode")
	}

	if raw, found := object["ZIPPlus4"]; found {
		err = json.Unmarshal(raw, &a.ZIPPlus4)
		if err != nil {
			return fmt.Errorf("error reading 'ZIPPlus4': %w", err)
		}
		delete(object, "ZIPPlus4")
	}

	if raw, found := object["city"]; found {
		err = json.Unmarshal(raw, &a.City)
		if err != nil {
			return fmt.Errorf("error reading 'city': %w", err)
		}
		delete(object, "city")
	}

	if raw, found := object["cityAbbreviation"]; found {
		err = json.Unmarshal(raw, &a.CityAbbreviation)
		if err != nil {
			return fmt.Errorf("error reading 'cityAbbreviation': %w", err)
		}
		delete(object, "cityAbbreviation")
	}

	if raw, found := object["secondaryAddress"]; found {
		err = json.Unmarshal(raw, &a.SecondaryAddress)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryAddress': %w", err)
		}
		delete(object, "secondaryAddress")
	}

	if raw, found := object["state"]; found {
		err = json.Unmarshal(raw, &a.State)
		if err != nil {
			return fmt.Errorf("error reading 'state': %w", err)
		}
		delete(object, "state")
	}

	if raw, found := object["streetAddress"]; found {
		err = json.Unmarshal(raw, &a.StreetAddress)
		if err != nil {
			return fmt.Errorf("error reading 'streetAddress': %w", err)
		}
		delete(object, "streetAddress")
	}

	if raw, found := object["streetAddressAbbreviation"]; found {
		err = json.Unmarshal(raw, &a.StreetAddressAbbreviation)
		if err != nil {
			return fmt.Errorf("error reading 'streetAddressAbbreviation': %w", err)
		}
		delete(object, "streetAddressAbbreviation")
	}

	if raw, found := object["urbanization"]; found {
		err = json.Unmarshal(raw, &a.Urbanization)
		if err != nil {
			return fmt.Errorf("error reading 'urbanization': %w", err)
		}
		delete(object, "urbanization")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DomesticAddress to handle AdditionalProperties
func (a DomesticAddress) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ZIPCode != nil {
		object["ZIPCode"], err = json.Marshal(a.ZIPCode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ZIPCode': %w", err)
		}
	}

	if a.ZIPPlus4 != nil {
		object["ZIPPlus4"], err = json.Marshal(a.ZIPPlus4)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ZIPPlus4': %w", err)
		}
	}

	if a.City != nil {
		object["city"], err = json.Marshal(a.City)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'city': %w", err)
		}
	}

	if a.CityAbbreviation != nil {
		object["cityAbbreviation"], err = json.Marshal(a.CityAbbreviation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cityAbbreviation': %w", err)
		}
	}

	if a.SecondaryAddress != nil {
		object["secondaryAddress"], err = json.Marshal(a.SecondaryAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryAddress': %w", err)
		}
	}

	if a.State != nil {
		object["state"], err = json.Marshal(a.State)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'state': %w", err)
		}
	}

	if a.StreetAddress != nil {
		object["streetAddress"], err = json.Marshal(a.StreetAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'streetAddress': %w", err)
		}
	}

	if a.StreetAddressAbbreviation != nil {
		object["streetAddressAbbreviation"], err = json.Marshal(a.StreetAddressAbbreviation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'streetAddressAbbreviation': %w", err)
		}
	}

	if a.Urbanization != nil {
		object["urbanization"], err = json.Marshal(a.Urbanization)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'urbanization': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ErrorMessage. Returns the specified
// element and whether it was found
func (a ErrorMessage) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ErrorMessage
func (a *ErrorMessage) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ErrorMessage to handle AdditionalProperties
func (a *ErrorMessage) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["apiVersion"]; found {
		err = json.Unmarshal(raw, &a.ApiVersion)
		if err != nil {
			return fmt.Errorf("error reading 'apiVersion': %w", err)
		}
		delete(object, "apiVersion")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ErrorMessage to handle AdditionalProperties
func (a ErrorMessage) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ApiVersion != nil {
		object["apiVersion"], err = json.Marshal(a.ApiVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'apiVersion': %w", err)
		}
	}

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ErrorMessage_Error_Errors_Source. Returns the specified
// element and whether it was found
func (a ErrorMessage_Error_Errors_Source) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ErrorMessage_Error_Errors_Source
func (a *ErrorMessage_Error_Errors_Source) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ErrorMessage_Error_Errors_Source to handle AdditionalProperties
func (a *ErrorMessage_Error_Errors_Source) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["example"]; found {
		err = json.Unmarshal(raw, &a.Example)
		if err != nil {
			return fmt.Errorf("error reading 'example': %w", err)
		}
		delete(object, "example")
	}

	if raw, found := object["parameter"]; found {
		err = json.Unmarshal(raw, &a.Parameter)
		if err != nil {
			return fmt.Errorf("error reading 'parameter': %w", err)
		}
		delete(object, "parameter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ErrorMessage_Error_Errors_Source to handle AdditionalProperties
func (a ErrorMessage_Error_Errors_Source) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Example != nil {
		object["example"], err = json.Marshal(a.Example)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'example': %w", err)
		}
	}

	if a.Parameter != nil {
		object["parameter"], err = json.Marshal(a.Parameter)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parameter': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ErrorMessage_Error_Errors_Item. Returns the specified
// element and whether it was found
func (a ErrorMessage_Error_Errors_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ErrorMessage_Error_Errors_Item
func (a *ErrorMessage_Error_Errors_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ErrorMessage_Error_Errors_Item to handle AdditionalProperties
func (a *ErrorMessage_Error_Errors_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ErrorMessage_Error_Errors_Item to handle AdditionalProperties
func (a ErrorMessage_Error_Errors_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Code != nil {
		object["code"], err = json.Marshal(a.Code)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'code': %w", err)
		}
	}

	if a.Detail != nil {
		object["detail"], err = json.Marshal(a.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ErrorMessage_Error. Returns the specified
// element and whether it was found
func (a ErrorMessage_Error) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ErrorMessage_Error
func (a *ErrorMessage_Error) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ErrorMessage_Error to handle AdditionalProperties
func (a *ErrorMessage_Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["errors"]; found {
		err = json.Unmarshal(raw, &a.Errors)
		if err != nil {
			return fmt.Errorf("error reading 'errors': %w", err)
		}
		delete(object, "errors")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ErrorMessage_Error to handle AdditionalProperties
func (a ErrorMessage_Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Code != nil {
		object["code"], err = json.Marshal(a.Code)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'code': %w", err)
		}
	}

	if a.Errors != nil {
		object["errors"], err = json.Marshal(a.Errors)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'errors': %w", err)
		}
	}

	if a.Message != nil {
		object["message"], err = json.Marshal(a.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAddress request
	GetAddress(ctx context.Context, params *GetAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCityState request
	GetCityState(ctx context.Context, params *GetCityStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetZIPCode request
	GetZIPCode(ctx context.Context, params *GetZIPCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAddress(ctx context.Context, params *GetAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddressRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCityState(ctx context.Context, params *GetCityStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCityStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetZIPCode(ctx context.Context, params *GetZIPCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetZIPCodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAddressRequest generates requests for GetAddress
func NewGetAddressRequest(server string, params *GetAddressParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/address")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Firm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm", runtime.ParamLocationQuery, *params.Firm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streetAddress", runtime.ParamLocationQuery, params.StreetAddress); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SecondaryAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondaryAddress", runtime.ParamLocationQuery, *params.SecondaryAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.City != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "city", runtime.ParamLocationQuery, *params.City); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Urbanization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urbanization", runtime.ParamLocationQuery, *params.Urbanization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ZIPCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ZIPCode", runtime.ParamLocationQuery, *params.ZIPCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ZIPPlus4 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ZIPPlus4", runtime.ParamLocationQuery, *params.ZIPPlus4); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCityStateRequest generates requests for GetCityState
func NewGetCityStateRequest(server string, params *GetCityStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/city-state")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ZIPCode", runtime.ParamLocationQuery, params.ZIPCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetZIPCodeRequest generates requests for GetZIPCode
func NewGetZIPCodeRequest(server string, params *GetZIPCodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zipcode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Firm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firm", runtime.ParamLocationQuery, *params.Firm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streetAddress", runtime.ParamLocationQuery, params.StreetAddress); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SecondaryAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secondaryAddress", runtime.ParamLocationQuery, *params.SecondaryAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "city", runtime.ParamLocationQuery, params.City); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ZIPCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ZIPCode", runtime.ParamLocationQuery, *params.ZIPCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ZIPPlus4 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ZIPPlus4", runtime.ParamLocationQuery, *params.ZIPPlus4); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAddressWithResponse request
	GetAddressWithResponse(ctx context.Context, params *GetAddressParams, reqEditors ...RequestEditorFn) (*GetAddressResponse, error)

	// GetCityStateWithResponse request
	GetCityStateWithResponse(ctx context.Context, params *GetCityStateParams, reqEditors ...RequestEditorFn) (*GetCityStateResponse, error)

	// GetZIPCodeWithResponse request
	GetZIPCodeWithResponse(ctx context.Context, params *GetZIPCodeParams, reqEditors ...RequestEditorFn) (*GetZIPCodeResponse, error)
}

type GetAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddressResponse
	XML200       *AddressResponse
	JSON400      *ErrorMessage
	XML400       *ErrorMessage
	JSON401      *ErrorMessage
	XML401       *ErrorMessage
	JSON403      *ErrorMessage
	XML403       *ErrorMessage
	JSON404      *ErrorMessage
	XML404       *ErrorMessage
	JSON429      *ErrorMessage
	XML429       *ErrorMessage
	JSON503      *ErrorMessage
	XML503       *ErrorMessage
}

// Status returns HTTPResponse.Status
func (r GetAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCityStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CityStateResponse
	XML200       *CityStateResponse
	JSON400      *ErrorMessage
	XML400       *ErrorMessage
	JSON401      *ErrorMessage
	XML401       *ErrorMessage
	JSON403      *ErrorMessage
	XML403       *ErrorMessage
	JSON429      *ErrorMessage
	XML429       *ErrorMessage
	JSON503      *ErrorMessage
	XML503       *ErrorMessage
}

// Status returns HTTPResponse.Status
func (r GetCityStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCityStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetZIPCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZIPCodeResponse
	XML200       *ZIPCodeResponse
	JSON400      *ErrorMessage
	XML400       *ErrorMessage
	JSON401      *ErrorMessage
	XML401       *ErrorMessage
	JSON403      *ErrorMessage
	XML403       *ErrorMessage
	JSON429      *ErrorMessage
	XML429       *ErrorMessage
	JSON503      *ErrorMessage
	XML503       *ErrorMessage
}

// Status returns HTTPResponse.Status
func (r GetZIPCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetZIPCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAddressWithResponse request returning *GetAddressResponse
func (c *ClientWithResponses) GetAddressWithResponse(ctx context.Context, params *GetAddressParams, reqEditors ...RequestEditorFn) (*GetAddressResponse, error) {
	rsp, err := c.GetAddress(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddressResponse(rsp)
}

// GetCityStateWithResponse request returning *GetCityStateResponse
func (c *ClientWithResponses) GetCityStateWithResponse(ctx context.Context, params *GetCityStateParams, reqEditors ...RequestEditorFn) (*GetCityStateResponse, error) {
	rsp, err := c.GetCityState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCityStateResponse(rsp)
}

// GetZIPCodeWithResponse request returning *GetZIPCodeResponse
func (c *ClientWithResponses) GetZIPCodeWithResponse(ctx context.Context, params *GetZIPCodeParams, reqEditors ...RequestEditorFn) (*GetZIPCodeResponse, error) {
	rsp, err := c.GetZIPCode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetZIPCodeResponse(rsp)
}

// ParseGetAddressResponse parses an HTTP response from a GetAddressWithResponse call
func ParseGetAddressResponse(rsp *http.Response) (*GetAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest AddressResponse
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 400:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 401:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 403:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 404:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 429:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 503:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML503 = &dest

	}

	return response, nil
}

// ParseGetCityStateResponse parses an HTTP response from a GetCityStateWithResponse call
func ParseGetCityStateResponse(rsp *http.Response) (*GetCityStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCityStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CityStateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest CityStateResponse
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 400:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 401:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 403:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 429:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 503:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML503 = &dest

	}

	return response, nil
}

// ParseGetZIPCodeResponse parses an HTTP response from a GetZIPCodeWithResponse call
func ParseGetZIPCodeResponse(rsp *http.Response) (*GetZIPCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetZIPCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZIPCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest ZIPCodeResponse
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 400:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 401:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 403:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 429:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 503:
		var dest ErrorMessage
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML503 = &dest

	}

	return response, nil
}
